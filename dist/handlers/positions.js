/**
 * Positions handler for MCP server
 * Fetches user positions from Solana V4.7.6 program (Mainnet)
 */
import { Connection, PublicKey } from '@solana/web3.js';
import bs58 from 'bs58';
import { PROGRAM_ID, RPC_ENDPOINT, DISCRIMINATORS, lamportsToSol, } from '../config.js';
import { getMarket } from './markets.js';
// =============================================================================
// POSITION DECODER
// =============================================================================
/**
 * Decode UserPosition account data from V4.7.6 struct
 *
 * UserPosition struct layout (from IDL):
 * - discriminator (8)
 * - user (Pubkey, 32)
 * - market_id (u64, 8)
 * - yes_amount (u64, 8)
 * - no_amount (u64, 8)
 * - claimed (bool, 1)
 * - bump (u8, 1)
 * - referred_by (Option<Pubkey>: 1 + 0/32)
 * - affiliate_fee_paid (u64, 8)
 * - reserved ([u8; 16], 16)
 */
function decodePosition(data, pubkey) {
    try {
        let offset = 8; // Skip discriminator
        // user (Pubkey, 32 bytes)
        const user = new PublicKey(data.slice(offset, offset + 32));
        offset += 32;
        // market_id (u64, 8 bytes)
        const marketId = data.readBigUInt64LE(offset);
        offset += 8;
        // yes_amount (u64, 8 bytes)
        const yesAmount = data.readBigUInt64LE(offset);
        offset += 8;
        // no_amount (u64, 8 bytes)
        const noAmount = data.readBigUInt64LE(offset);
        offset += 8;
        // claimed (bool, 1 byte)
        const claimed = data.readUInt8(offset) === 1;
        offset += 1;
        // bump (u8, 1 byte)
        offset += 1;
        // referred_by (Option<Pubkey>: 1 byte discriminant + optional 32 bytes)
        const hasReferrer = data.readUInt8(offset) === 1;
        offset += 1;
        let referredBy = null;
        if (hasReferrer) {
            referredBy = new PublicKey(data.slice(offset, offset + 32)).toBase58();
            offset += 32;
        }
        // affiliate_fee_paid (u64, 8 bytes)
        const affiliateFeePaid = data.readBigUInt64LE(offset);
        // Derived fields
        const yesAmountSol = round4(lamportsToSol(yesAmount));
        const noAmountSol = round4(lamportsToSol(noAmount));
        const totalAmountSol = round4(yesAmountSol + noAmountSol);
        // Determine primary side
        let side;
        if (yesAmount > 0n && noAmount > 0n) {
            side = 'Both';
        }
        else if (yesAmount > 0n) {
            side = 'Yes';
        }
        else {
            side = 'No';
        }
        return {
            publicKey: pubkey.toBase58(),
            user: user.toBase58(),
            marketId: marketId.toString(),
            yesAmountSol,
            noAmountSol,
            totalAmountSol,
            side,
            claimed,
            referredBy,
            affiliateFeePaidSol: round4(lamportsToSol(affiliateFeePaid)),
        };
    }
    catch (err) {
        console.error('Error decoding position:', err);
        return null;
    }
}
// =============================================================================
// PUBLIC API
// =============================================================================
/**
 * Get all positions for a wallet
 */
export async function getPositions(walletAddress) {
    const connection = new Connection(RPC_ENDPOINT, 'confirmed');
    try {
        const wallet = new PublicKey(walletAddress);
        // Get all position accounts for this user
        // Note: Solana RPC expects base58 encoding for memcmp bytes
        const accounts = await connection.getProgramAccounts(PROGRAM_ID, {
            filters: [
                {
                    memcmp: {
                        offset: 0,
                        bytes: bs58.encode(DISCRIMINATORS.USER_POSITION),
                    },
                },
                {
                    memcmp: {
                        offset: 8, // After discriminator
                        bytes: wallet.toBase58(),
                    },
                },
            ],
        });
        const positions = [];
        for (const { account, pubkey } of accounts) {
            const position = decodePosition(account.data, pubkey);
            if (position) {
                positions.push(position);
            }
        }
        // Sort by market ID (newest markets first)
        positions.sort((a, b) => Number(BigInt(b.marketId) - BigInt(a.marketId)));
        return positions;
    }
    catch (err) {
        console.error('Error fetching positions:', err);
        return [];
    }
}
/**
 * Derive market PDA from market_id
 */
function deriveMarketPda(marketId) {
    const marketIdBigInt = BigInt(marketId);
    const marketIdBuffer = Buffer.alloc(8);
    marketIdBuffer.writeBigUInt64LE(marketIdBigInt);
    const [pda] = PublicKey.findProgramAddressSync([Buffer.from('market'), marketIdBuffer], PROGRAM_ID);
    return pda.toBase58();
}
/**
 * Get positions with enriched market data
 */
export async function getPositionsEnriched(walletAddress) {
    const positions = await getPositions(walletAddress);
    // Derive market PDAs from market_id
    const positionsWithPda = positions.map(p => ({
        ...p,
        marketPda: deriveMarketPda(p.marketId),
    }));
    // Batch fetch market data for unique markets
    const uniqueMarkets = [...new Set(positionsWithPda.map(p => p.marketPda))];
    const marketData = new Map();
    await Promise.all(uniqueMarkets.map(async (marketPda) => {
        if (marketPda) {
            const market = await getMarket(marketPda);
            if (market) {
                marketData.set(marketPda, market);
            }
        }
    }));
    // Enrich positions with market data
    return positionsWithPda.map(position => {
        const market = position.marketPda ? marketData.get(position.marketPda) : null;
        if (!market)
            return position;
        // Calculate potential payout if position is winning
        let potentialPayout;
        const positionAmount = position.side === 'Yes' ? position.yesAmountSol : position.noAmountSol;
        if (market.status === 'Resolved' && market.winningOutcome === position.side) {
            const totalPool = market.yesPoolSol + market.noPoolSol;
            const winningPool = position.side === 'Yes' ? market.yesPoolSol : market.noPoolSol;
            if (winningPool > 0) {
                const share = positionAmount / winningPool;
                const grossPayout = share * totalPool;
                const profit = grossPayout - positionAmount;
                const fee = profit > 0 ? (profit * market.platformFeeBps) / 10000 : 0;
                potentialPayout = round4(grossPayout - fee);
            }
        }
        return {
            ...position,
            marketQuestion: market.question,
            marketStatus: market.status,
            marketOutcome: market.winningOutcome,
            potentialPayout,
        };
    });
}
/**
 * Get position summary with statistics
 */
export async function getPositionsSummary(walletAddress) {
    const positions = await getPositionsEnriched(walletAddress);
    const totalBetSol = positions.reduce((sum, p) => sum + p.totalAmountSol, 0);
    const activePositions = positions.filter(p => !p.claimed).length;
    const claimedPositions = positions.filter(p => p.claimed).length;
    // Count winning/losing/pending based on market status and outcome
    let winningPositions = 0;
    let losingPositions = 0;
    let pendingPositions = 0;
    for (const position of positions) {
        if (!position.marketStatus || position.marketStatus === 'Active' || position.marketStatus === 'Closed') {
            pendingPositions++;
        }
        else if (position.marketStatus === 'Resolved') {
            if (position.marketOutcome === position.side) {
                winningPositions++;
            }
            else if (position.marketOutcome === 'Invalid') {
                // Refund case
                pendingPositions++;
            }
            else {
                losingPositions++;
            }
        }
        else if (position.marketStatus === 'Cancelled') {
            // Refund case
            pendingPositions++;
        }
    }
    return {
        wallet: walletAddress,
        totalPositions: positions.length,
        totalBetSol: round4(totalBetSol),
        activePositions,
        claimedPositions,
        winningPositions,
        losingPositions,
        pendingPositions,
        positions,
    };
}
// =============================================================================
// HELPERS
// =============================================================================
function round4(n) {
    return Math.round(n * 10000) / 10000;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9zaXRpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2hhbmRsZXJzL3Bvc2l0aW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7QUFDSCxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3hELE9BQU8sSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUN4QixPQUFPLEVBQ0wsVUFBVSxFQUNWLFlBQVksRUFDWixjQUFjLEVBQ2QsYUFBYSxHQUNkLE1BQU0sY0FBYyxDQUFDO0FBQ3RCLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFxQ3pDLGdGQUFnRjtBQUNoRixtQkFBbUI7QUFDbkIsZ0ZBQWdGO0FBRWhGOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBQ0gsU0FBUyxjQUFjLENBQUMsSUFBWSxFQUFFLE1BQWlCO0lBQ3JELElBQUksQ0FBQztRQUNILElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLHFCQUFxQjtRQUVyQywwQkFBMEI7UUFDMUIsTUFBTSxJQUFJLEdBQUcsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsTUFBTSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDNUQsTUFBTSxJQUFJLEVBQUUsQ0FBQztRQUViLDJCQUEyQjtRQUMzQixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzlDLE1BQU0sSUFBSSxDQUFDLENBQUM7UUFFWiw0QkFBNEI7UUFDNUIsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMvQyxNQUFNLElBQUksQ0FBQyxDQUFDO1FBRVosMkJBQTJCO1FBQzNCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDOUMsTUFBTSxJQUFJLENBQUMsQ0FB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LEVBQUUsQ0FBQztZQUNoRCxJQUFJLFFBQVEsQ0FBQyxhQUFhLEtBQUssUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUM3QyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ3JCLENBQUM7aUJBQU0sSUFBSSxRQUFRLENBQUMsYUFBYSxLQUFLLFNBQVMsRUFBRSxDQUFDO2dCQUNoRCxjQUFjO2dCQUNkLGdCQUFnQixFQUFFLENBQUM7WUFDckIsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLGVBQWUsRUFBRSxDQUFDO1lBQ3BCLENBQUM7UUFDSCxDQUFDO2FBQU0sSUFBSSxRQUFRLENBQUMsWUFBWSxLQUFLLFdBQVcsRUFBRSxDQUFDO1lBQ2pELGNBQWM7WUFDZCxnQkFBZ0IsRUFBRSxDQUFDO1FBQ3JCLENBQUM7SUFDSCxDQUFDO0lBRUQsT0FBTztRQUNMLE1BQU0sRUFBRSxhQUFhO1FBQ3JCLGNBQWMsRUFBRSxTQUFTLENBQUMsTUFBTTtRQUNoQyxXQUFXLEVBQUUsTUFBTSxDQUFDLFdBQVcsQ0FBQztRQUNoQyxlQUFlO1FBQ2YsZ0JBQWdCO1FBQ2hCLGdCQUFnQjtRQUNoQixlQUFlO1FBQ2YsZ0JBQWdCO1FBQ2hCLFNBQVM7S0FDVixDQUFDO0FBQ0osQ0FBQztBQUVELGdGQUFnRjtBQUNoRixVQUFVO0FBQ1YsZ0ZBQWdGO0FBRWhGLFNBQVMsTUFBTSxDQUFDLENBQVM7SUFDdkIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUM7QUFDdkMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUG9zaXRpb25zIGhhbmRsZXIgZm9yIE1DUCBzZXJ2ZXJcbiAqIEZldGNoZXMgdXNlciBwb3NpdGlvbnMgZnJvbSBTb2xhbmEgVjQuNy42IHByb2dyYW0gKE1haW5uZXQpXG4gKi9cbmltcG9ydCB7IENvbm5lY3Rpb24sIFB1YmxpY0tleSB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgYnM1OCBmcm9tICdiczU4JztcbmltcG9ydCB7XG4gIFBST0dSQU1fSUQsXG4gIFJQQ19FTkRQT0lOVCxcbiAgRElTQ1JJTUlOQVRPUlMsXG4gIGxhbXBvcnRzVG9Tb2wsXG59IGZyb20gJy4uL2NvbmZpZy5qcyc7XG5pbXBvcnQgeyBnZXRNYXJrZXQgfSBmcm9tICcuL21hcmtldHMuanMnO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVFlQRVNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9zaXRpb24ge1xuICBwdWJsaWNLZXk6IHN0cmluZztcbiAgdXNlcjogc3RyaW5nO1xuICBtYXJrZXRJZDogc3RyaW5nO1xuICB5ZXNBbW91bnRTb2w6IG51bWJlcjtcbiAgbm9BbW91bnRTb2w6IG51bWJlcjtcbiAgdG90YWxBbW91bnRTb2w6IG51bWJlcjtcbiAgc2lkZTogJ1llcycgfCAnTm8nIHwgJ0JvdGgnOyAvLyBEZXJpdmVkOiB3aGljaCBzaWRlIGhhcyBtb3JlXG4gIGNsYWltZWQ6IGJvb2xlYW47XG4gIHJlZmVycmVkQnk6IHN0cmluZyB8IG51bGw7XG4gIGFmZmlsaWF0ZUZlZVBhaWRTb2w6IG51bWJlcjtcbiAgLy8gRW5yaWNoZWQgZmllbGRzIChvcHRpb25hbCwgZnJvbSBtYXJrZXQgbG9va3VwKVxuICBtYXJrZXRQZGE/OiBzdHJpbmc7XG4gIG1hcmtldFF1ZXN0aW9uPzogc3RyaW5nO1xuICBtYXJrZXRTdGF0dXM/OiBzdHJpbmc7XG4gIG1hcmtldE91dGNvbWU/OiBzdHJpbmcgfCBudWxsO1xuICBwb3RlbnRpYWxQYXlvdXQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9zaXRpb25TdW1tYXJ5IHtcbiAgd2FsbGV0OiBzdHJpbmc7XG4gIHRvdGFsUG9zaXRpb25zOiBudW1iZXI7XG4gIHRvdGFsQmV0U29sOiBudW1iZXI7XG4gIGFjdGl2ZVBvc2l0aW9uczogbnVtYmVyO1xuICBjbGFpbWVkUG9zaXRpb25zOiBudW1iZXI7XG4gIHdpbm5pbmdQb3NpdGlvbnM6IG51bWJlcjtcbiAgbG9zaW5nUG9zaXRpb25zOiBudW1iZXI7XG4gIHBlbmRpbmdQb3NpdGlvbnM6IG51bWJlcjtcbiAgcG9zaXRpb25zOiBQb3NpdGlvbltdO1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUE9TSVRJT04gREVDT0RFUlxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBEZWNvZGUgVXNlclBvc2l0aW9uIGFjY291bnQgZGF0YSBmcm9tIFY0LjcuNiBzdHJ1Y3RcbiAqXG4gKiBVc2VyUG9zaXRpb24gc3RydWN0IGxheW91dCAoZnJvbSBJREwpOlxuICogLSBkaXNjcmltaW5hdG9yICg4KVxuICogLSB1c2VyIChQdWJrZXksIDMyKVxuICogLSBtYXJrZXRfaWQgKHU2NCwgOClcbiAqIC0geWVzX2Ftb3VudCAodTY0LCA4KVxuICogLSBub19hbW91bnQgKHU2NCwgOClcbiAqIC0gY2xhaW1lZCAoYm9vbCwgMSlcbiAqIC0gYnVtcCAodTgsIDEpXG4gKiAtIHJlZmVycmVkX2J5IChPcHRpb248UHVia2V5PjogMSArIDAvMzIpXG4gKiAtIGFmZmlsaWF0ZV9mZWVfcGFpZCAodTY0LCA4KVxuICogLSByZXNlcnZlZCAoW3U4OyAxNl0sIDE2KVxuICovXG5mdW5jdGlvbiBkZWNvZGVQb3NpdGlvbihkYXRhOiBCdWZmZXIsIHB1YmtleTogUHVibGljS2V5KTogUG9zaXRpb24gfCBudWxsIHtcbiAgdHJ5IHtcbiAgICBsZXQgb2Zmc2V0ID0gODsgLy8gU2tpcCBkaXNjcmltaW5hdG9yXG5cbiAgICAvLyB1c2VyIChQdWJrZXksIDMyIGJ5dGVzKVxuICAgIGNvbnN0IHVzZXIgPSBuZXcgUHVibGljS2V5KGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyAzMikpO1xuICAgIG9mZnNldCArPSAzMjtcblxuICAgIC8vIG1hcmtldF9pZCAodTY0LCA4IGJ5dGVzKVxuICAgIGNvbnN0IG1hcmtldElkID0gZGF0YS5yZWFkQmlnVUludDY0TEUob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gODtcblxuICAgIC8vIHllc19hbW91bnQgKHU2NCwgOCBieXRlcylcbiAgICBjb25zdCB5ZXNBbW91bnQgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpO1xuICAgIG9mZnNldCArPSA4O1xuXG4gICAgLy8gbm9fYW1vdW50ICh1NjQsIDggYnl0ZXMpXG4gICAgY29uc3Qgbm9BbW91bnQgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpO1xuICAgIG9mZnNldCArPSA4O1xuXG4gICAgLy8gY2xhaW1lZCAoYm9vbCwgMSBieXRlKVxuICAgIGNvbnN0IGNsYWltZWQgPSBkYXRhLnJlYWRVSW50OChvZmZzZXQpID09PSAxO1xuICAgIG9mZnNldCArPSAxO1xuXG4gICAgLy8gYnVtcCAodTgsIDEgYnl0ZSlcbiAgICBvZmZzZXQgKz0gMTtcblxuICAgIC8vIHJlZmVycmVkX2J5IChPcHRpb248UHVia2V5PjogMSBieXRlIGRpc2NyaW1pbmFudCArIG9wdGlvbmFsIDMyIGJ5dGVzKVxuICAgIGNvbnN0IGhhc1JlZmVycmVyID0gZGF0YS5yZWFkVUludDgob2Zmc2V0KSA9PT0gMTtcbiAgICBvZmZzZXQgKz0gMTtcbiAgICBsZXQgcmVmZXJyZWRCeTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgaWYgKGhhc1JlZmVycmVyKSB7XG4gICAgICByZWZlcnJlZEJ5ID0gbmV3IFB1YmxpY0tleShkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgMzIpKS50b0Jhc2U1OCgpO1xuICAgICAgb2Zmc2V0ICs9IDMyO1xuICAgIH1cblxuICAgIC8vIGFmZmlsaWF0ZV9mZWVfcGFpZCAodTY0LCA4IGJ5dGVzKVxuICAgIGNvbnN0IGFmZmlsaWF0ZUZlZVBhaWQgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpO1xuXG4gICAgLy8gRGVyaXZlZCBmaWVsZHNcbiAgICBjb25zdCB5ZXNBbW91bnRTb2wgPSByb3VuZDQobGFtcG9ydHNUb1NvbCh5ZXNBbW91bnQpKTtcbiAgICBjb25zdCBub0Ftb3VudFNvbCA9IHJvdW5kNChsYW1wb3J0c1RvU29sKG5vQW1vdW50KSk7XG4gICAgY29uc3QgdG90YWxBbW91bnRTb2wgPSByb3VuZDQoeWVzQW1vdW50U29sICsgbm9BbW91bnRTb2wpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHByaW1hcnkgc2lkZVxuICAgIGxldCBzaWRlOiAnWWVzJyB8ICdObycgfCAnQm90aCc7XG4gICAgaWYgKHllc0Ftb3VudCA+IDBuICYmIG5vQW1vdW50ID4gMG4pIHtcbiAgICAgIHNpZGUgPSAnQm90aCc7XG4gICAgfSBlbHNlIGlmICh5ZXNBbW91bnQgPiAwbikge1xuICAgICAgc2lkZSA9ICdZZXMnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWRlID0gJ05vJztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHVibGljS2V5OiBwdWJrZXkudG9CYXNlNTgoKSxcbiAgICAgIHVzZXI6IHVzZXIudG9CYXNlNTgoKSxcbiAgICAgIG1hcmtldElkOiBtYXJrZXRJZC50b1N0cmluZygpLFxuICAgICAgeWVzQW1vdW50U29sLFxuICAgICAgbm9BbW91bnRTb2wsXG4gICAgICB0b3RhbEFtb3VudFNvbCxcbiAgICAgIHNpZGUsXG4gICAgICBjbGFpbWVkLFxuICAgICAgcmVmZXJyZWRCeSxcbiAgICAgIGFmZmlsaWF0ZUZlZVBhaWRTb2w6IHJvdW5kNChsYW1wb3J0c1RvU29sKGFmZmlsaWF0ZUZlZVBhaWQpKSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWNvZGluZyBwb3NpdGlvbjonLCBlcnIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQVUJMSUMgQVBJXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEdldCBhbGwgcG9zaXRpb25zIGZvciBhIHdhbGxldFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UG9zaXRpb25zKHdhbGxldEFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8UG9zaXRpb25bXT4ge1xuICBjb25zdCBjb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oUlBDX0VORFBPSU5ULCAnY29uZmlybWVkJyk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB3YWxsZXQgPSBuZXcgUHVibGljS2V5KHdhbGxldEFkZHJlc3MpO1xuXG4gICAgLy8gR2V0IGFsbCBwb3NpdGlvbiBhY2NvdW50cyBmb3IgdGhpcyB1c2VyXG4gICAgLy8gTm90ZTogU29sYW5hIFJQQyBleHBlY3RzIGJhc2U1OCBlbmNvZGluZyBmb3IgbWVtY21wIGJ5dGVzXG4gICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBjb25uZWN0aW9uLmdldFByb2dyYW1BY2NvdW50cyhQUk9HUkFNX0lELCB7XG4gICAgICBmaWx0ZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBtZW1jbXA6IHtcbiAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgIGJ5dGVzOiBiczU4LmVuY29kZShESVNDUklNSU5BVE9SUy5VU0VSX1BPU0lUSU9OKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbWVtY21wOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IDgsIC8vIEFmdGVyIGRpc2NyaW1pbmF0b3JcbiAgICAgICAgICAgIGJ5dGVzOiB3YWxsZXQudG9CYXNlNTgoKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHBvc2l0aW9uczogUG9zaXRpb25bXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCB7IGFjY291bnQsIHB1YmtleSB9IG9mIGFjY291bnRzKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGRlY29kZVBvc2l0aW9uKGFjY291bnQuZGF0YSBhcyBCdWZmZXIsIHB1YmtleSk7XG4gICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgcG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNvcnQgYnkgbWFya2V0IElEIChuZXdlc3QgbWFya2V0cyBmaXJzdClcbiAgICBwb3NpdGlvbnMuc29ydCgoYSwgYikgPT4gTnVtYmVyKEJpZ0ludChiLm1hcmtldElkKSAtIEJpZ0ludChhLm1hcmtldElkKSkpO1xuXG4gICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcG9zaXRpb25zOicsIGVycik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuICogRGVyaXZlIG1hcmtldCBQREEgZnJvbSBtYXJrZXRfaWRcbiAqL1xuZnVuY3Rpb24gZGVyaXZlTWFya2V0UGRhKG1hcmtldElkOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBtYXJrZXRJZEJpZ0ludCA9IEJpZ0ludChtYXJrZXRJZCk7XG4gIGNvbnN0IG1hcmtldElkQnVmZmVyID0gQnVmZmVyLmFsbG9jKDgpO1xuICBtYXJrZXRJZEJ1ZmZlci53cml0ZUJpZ1VJbnQ2NExFKG1hcmtldElkQmlnSW50KTtcbiAgY29uc3QgW3BkYV0gPSBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzU3luYyhcbiAgICBbQnVmZmVyLmZyb20oJ21hcmtldCcpLCBtYXJrZXRJZEJ1ZmZlcl0sXG4gICAgUFJPR1JBTV9JRFxuICApO1xuICByZXR1cm4gcGRhLnRvQmFzZTU4KCk7XG59XG5cbi8qKlxuICogR2V0IHBvc2l0aW9ucyB3aXRoIGVucmljaGVkIG1hcmtldCBkYXRhXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQb3NpdGlvbnNFbnJpY2hlZCh3YWxsZXRBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPFBvc2l0aW9uW10+IHtcbiAgY29uc3QgcG9zaXRpb25zID0gYXdhaXQgZ2V0UG9zaXRpb25zKHdhbGxldEFkZHJlc3MpO1xuXG4gIC8vIERlcml2ZSBtYXJrZXQgUERBcyBmcm9tIG1hcmtldF9pZFxuICBjb25zdCBwb3NpdGlvbnNXaXRoUGRhID0gcG9zaXRpb25zLm1hcChwID0+ICh7XG4gICAgLi4ucCxcbiAgICBtYXJrZXRQZGE6IGRlcml2ZU1hcmtldFBkYShwLm1hcmtldElkKSxcbiAgfSkpO1xuXG4gIC8vIEJhdGNoIGZldGNoIG1hcmtldCBkYXRhIGZvciB1bmlxdWUgbWFya2V0c1xuICBjb25zdCB1bmlxdWVNYXJrZXRzID0gWy4uLm5ldyBTZXQocG9zaXRpb25zV2l0aFBkYS5tYXAocCA9PiBwLm1hcmtldFBkYSkpXTtcbiAgY29uc3QgbWFya2V0RGF0YSA9IG5ldyBNYXA8c3RyaW5nLCBBd2FpdGVkPFJldHVyblR5cGU8dHlwZW9mIGdldE1hcmtldD4+PigpO1xuXG4gIGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHVuaXF1ZU1hcmtldHMubWFwKGFzeW5jIChtYXJrZXRQZGEpID0+IHtcbiAgICAgIGlmIChtYXJrZXRQZGEpIHtcbiAgICAgICAgY29uc3QgbWFya2V0ID0gYXdhaXQgZ2V0TWFya2V0KG1hcmtldFBkYSk7XG4gICAgICAgIGlmIChtYXJrZXQpIHtcbiAgICAgICAgICBtYXJrZXREYXRhLnNldChtYXJrZXRQZGEsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICApO1xuXG4gIC8vIEVucmljaCBwb3NpdGlvbnMgd2l0aCBtYXJrZXQgZGF0YVxuICByZXR1cm4gcG9zaXRpb25zV2l0aFBkYS5tYXAocG9zaXRpb24gPT4ge1xuICAgIGNvbnN0IG1hcmtldCA9IHBvc2l0aW9uLm1hcmtldFBkYSA/IG1hcmtldERhdGEuZ2V0KHBvc2l0aW9uLm1hcmtldFBkYSkgOiBudWxsO1xuICAgIGlmICghbWFya2V0KSByZXR1cm4gcG9zaXRpb247XG5cbiAgICAvLyBDYWxjdWxhdGUgcG90ZW50aWFsIHBheW91dCBpZiBwb3NpdGlvbiBpcyB3aW5uaW5nXG4gICAgbGV0IHBvdGVudGlhbFBheW91dDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IHBvc2l0aW9uQW1vdW50ID0gcG9zaXRpb24uc2lkZSA9PT0gJ1llcycgPyBwb3NpdGlvbi55ZXNBbW91bnRTb2wgOiBwb3NpdGlvbi5ub0Ftb3VudFNvbDtcbiAgICBpZiAobWFya2V0LnN0YXR1cyA9PT0gJ1Jlc29sdmVkJyAmJiBtYXJrZXQud2lubmluZ091dGNvbWUgPT09IHBvc2l0aW9uLnNpZGUpIHtcbiAgICAgIGNvbnN0IHRvdGFsUG9vbCA9IG1hcmtldC55ZXNQb29sU29sICsgbWFya2V0Lm5vUG9vbFNvbDtcbiAgICAgIGNvbnN0IHdpbm5pbmdQb29sID0gcG9zaXRpb24uc2lkZSA9PT0gJ1llcycgPyBtYXJrZXQueWVzUG9vbFNvbCA6IG1hcmtldC5ub1Bvb2xTb2w7XG4gICAgICBpZiAod2lubmluZ1Bvb2wgPiAwKSB7XG4gICAgICAgIGNvbnN0IHNoYXJlID0gcG9zaXRpb25BbW91bnQgLyB3aW5uaW5nUG9vbDtcbiAgICAgICAgY29uc3QgZ3Jvc3NQYXlvdXQgPSBzaGFyZSAqIHRvdGFsUG9vbDtcbiAgICAgICAgY29uc3QgcHJvZml0ID0gZ3Jvc3NQYXlvdXQgLSBwb3NpdGlvbkFtb3VudDtcbiAgICAgICAgY29uc3QgZmVlID0gcHJvZml0ID4gMCA/IChwcm9maXQgKiBtYXJrZXQucGxhdGZvcm1GZWVCcHMpIC8gMTAwMDAgOiAwO1xuICAgICAgICBwb3RlbnRpYWxQYXlvdXQgPSByb3VuZDQoZ3Jvc3NQYXlvdXQgLSBmZWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5wb3NpdGlvbixcbiAgICAgIG1hcmtldFF1ZXN0aW9uOiBtYXJrZXQucXVlc3Rpb24sXG4gICAgICBtYXJrZXRTdGF0dXM6IG1hcmtldC5zdGF0dXMsXG4gICAgICBtYXJrZXRPdXRjb21lOiBtYXJrZXQud2lubmluZ091dGNvbWUsXG4gICAgICBwb3RlbnRpYWxQYXlvdXQsXG4gICAgfTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHBvc2l0aW9uIHN1bW1hcnkgd2l0aCBzdGF0aXN0aWNzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQb3NpdGlvbnNTdW1tYXJ5KHdhbGxldEFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8UG9zaXRpb25TdW1tYXJ5PiB7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IGF3YWl0IGdldFBvc2l0aW9uc0VucmljaGVkKHdhbGxldEFkZHJlc3MpO1xuXG4gIGNvbnN0IHRvdGFsQmV0U29sID0gcG9zaXRpb25zLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLnRvdGFsQW1vdW50U29sLCAwKTtcbiAgY29uc3QgYWN0aXZlUG9zaXRpb25zID0gcG9zaXRpb25zLmZpbHRlcihwID0+ICFwLmNsYWltZWQpLmxlbmd0aDtcbiAgY29uc3QgY2xhaW1lZFBvc2l0aW9ucyA9IHBvc2l0aW9ucy5maWx0ZXIocCA9PiBwLmNsYWltZWQpLmxlbmd0aDtcblxuICAvLyBDb3VudCB3aW5uaW5nL2xvc2luZy9wZW5kaW5nIGJhc2VkIG9uIG1hcmtldCBzdGF0dXMgYW5kIG91dGNvbWVcbiAgbGV0IHdpbm5pbmdQb3NpdGlvbnMgPSAwO1xuICBsZXQgbG9zaW5nUG9zaXRpb25zID0gMDtcbiAgbGV0IHBlbmRpbmdQb3NpdGlvbnMgPSAwO1xuXG4gIGZvciAoY29uc3QgcG9zaXRpb24gb2YgcG9zaXRpb25zKSB7XG4gICAgaWYgKCFwb3NpdGlvbi5tYXJrZXRTdGF0dXMgfHwgcG9zaXRpb24ubWFya2V0U3RhdHVzID09PSAnQWN0aXZlJyB8fCBwb3NpdGlvbi5tYXJrZXRTdGF0dXMgPT09ICdDbG9zZWQnKSB7XG4gICAgICBwZW5kaW5nUG9zaXRpb25zKys7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbi5tYXJrZXRTdGF0dXMgPT09ICdSZXNvbHZlZCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbi5tYXJrZXRPdXRjb21lID09PSBwb3NpdGlvbi5zaWRlKSB7XG4gICAgICAgIHdpbm5pbmdQb3NpdGlvbnMrKztcbiAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24ubWFya2V0T3V0Y29tZSA9PT0gJ0ludmFsaWQnKSB7XG4gICAgICAgIC8vIFJlZnVuZCBjYXNlXG4gICAgICAgIHBlbmRpbmdQb3NpdGlvbnMrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvc2luZ1Bvc2l0aW9ucysrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24ubWFya2V0U3RhdHVzID09PSAnQ2FuY2VsbGVkJykge1xuICAgICAgLy8gUmVmdW5kIGNhc2VcbiAgICAgIHBlbmRpbmdQb3NpdGlvbnMrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdhbGxldDogd2FsbGV0QWRkcmVzcyxcbiAgICB0b3RhbFBvc2l0aW9uczogcG9zaXRpb25zLmxlbmd0aCxcbiAgICB0b3RhbEJldFNvbDogcm91bmQ0KHRvdGFsQmV0U29sKSxcbiAgICBhY3RpdmVQb3NpdGlvbnMsXG4gICAgY2xhaW1lZFBvc2l0aW9ucyxcbiAgICB3aW5uaW5nUG9zaXRpb25zLFxuICAgIGxvc2luZ1Bvc2l0aW9ucyxcbiAgICBwZW5kaW5nUG9zaXRpb25zLFxuICAgIHBvc2l0aW9ucyxcbiAgfTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEhFTFBFUlNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIHJvdW5kNChuOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5yb3VuZChuICogMTAwMDApIC8gMTAwMDA7XG59XG4iXX0=